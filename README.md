# ✦ Tiny Object Notation ✦
～ jsonをちっちゃく効率的に

[[EN](https://github.com/371tti/TinyObjectNotation-TON-/blob/master/README-en.md)]
## **概要**
**Tiny Object Notation**はJsonの柔軟でシンプルなバイナリ改良です。  

以下の要素を追加します
- 型情報 + 型
- 長さ情報
- 高速なキー一致
- 約20%の縮小
- 最大2^64byteのデータサイズをサポート

DB、ネットワークなどで共有して軽量とパフォーマンスが必要なときに役立つはずです。

圧縮はこれを含む上位レイヤーで実装すべきです。
### **他フォーマットとの比較**

| **特徴**               | **JSON**                          | **BSON**                      | **TON** |
|------------------------|------------------------------------|--------------------------------|------------------------------------------|
| **データサイズ**        | 大きい（文字列冗長）              | 比較的小さい                   | **最小（キー効率化）**                   |
| **キー検索速度**        | 低速（完全文字列比較）            | 中速（NULL終端で効率化）       | **高速（ハッシュ比較 + 文字列検証）**    |
| **型情報の管理**        | 暗黙的                           | 明示的（1バイト）              | **軽量（6bit管理）**                     |
| **柔軟性**             | 高い                              | 中程度（MongoDB特化）          | **高い（汎用設計）**                     |
| **用途**               | 人間可読データの保存・通信        | データベース用途               | 高速・軽量データ処理                    |


### **例: サンプルデータのフォーマット**
```json
{
  "name": "Alice",
  "age": 25,
  "isStudent": false
}
```

```
0b01010001 0x00 0x22
0b01010100 0x04 "name" 0b00111001 0x05 "Alice"
0b00110000 0x03 "age" 0b00001000 0x19 0x00 0x00 0x00
0b01100001 0x00 0x09 "isStudent" 0b00000100 0x00
```
**合計サイズ**:
- JSON: 48バイト  
- BSON: 42バイト  
- ✦TON: **41バイト** 
---

# **TinyObjectNotation (TON) 仕様書**

## 目次
1. [フォーマットの基本構造](#1-フォーマットの基本構造)  
   1.1 [フィールドの説明](#11-フィールドの説明)  
2. [基本型](#2-基本型)  
3. [コレクション型](#3-コレクション型)  
   3.1 [Object](#31-object)  
   3.2 [Array](#32-array)  
   3.3 [WrappedJSON](#33-wrappedjson)  
   3.4 [Meta](#34-meta)  
4. [注意事項](#4-注意事項)  
5. [パーサーポリシー](#5-パーサーポリシー)  
6. [シリアライザーポリシー](#6-シリアライザーポリシー)  

---

## **1. フォーマットの基本構造**

TON は、以下の統一された形式でデータをエンコードします。

```
<6bit: 識別子> <2bit: 長さサイズ> <8-64bit: データ長> <nbyte: データ本体>
```

### **1.1 フィールドの説明**
1. **識別子 (6ビット)**  
   データの種類または役割を示すための6ビット。  
   - **値 (Value)**: データ型を識別します（例: `Int`, `String`, `Array` など）。  
   - **キー (Key)**: `Object` の中でのみ使用し、**キー文字列を SHA-256 でハッシュ化した結果の**  
     **「**末尾バイト**(32バイト目)**の **下位6ビット** を格納します。  
     - 例: `hash = SHA-256("name")` → 32バイトのうち最終バイト `hash[31]` の `0x3F`(下位6ビット) 演算結果。  
     - これにより、**単純なマスク演算** (`hash[31] & 0x3F`) だけで6ビットを取り出せるため、実装で処理が高速化できます。

2. **長さサイズ (2ビット)**  
   データ長（次の「データ長」フィールド）の**サイズ**を表します。
   - `00` : 1バイト（最大 255 バイト）
   - `01` : 2バイト（最大 65,535 バイト）
   - `10` : 4バイト（最大 4,294,967,295 バイト）
   - `11` : 8バイト（最大 18,446,744,073,709,551,615 バイト）

3. **データ長 (8-64ビット, リトルエンディアン)**  
   実際のデータ本体のバイト数。

4. **データ本体 (可変長)**  
   データ本体となるバイト列。上記「データ長」に基づいて読み取る。

---

## **2. 基本型**

TON の**値 (Value)**として利用される基本型の6ビット識別子は以下の通りです。  
（`Object` のキー用6ビットは「Key」で別途扱うため、下記とは衝突し得る点に注意）

| 種類            | 識別子 (6bit)  | 説明                                                            |
|:----------------|:--------------:|:----------------------------------------------------------------|
| **Null**        | `0b000000`     | 値なし                                                          |
| **Boolean**     | `0b000001`     | 真偽値 (`true` / `false`)                                       |
| **Int<n>**      | `0b000010`     | 可変長有符号整数 (1～128バイト, JSのBigInt相当含む)             |
| **UInt<n>**     | `0b000011`     | 可変長無符号整数 (1～128バイト)                                 |
| **Float<n>**    | `0b000100`     | 可変長浮動小数点数 (2～16バイト)                                |
| **BCD**         | `0b000101`     | Binary Coded Decimal (4bit/1桁)                                 |
| **String**      | `0b000110`     | UTF-8エンコードされた文字列                                     |
| **Binary**      | `0b000111`     | 任意のバイナリデータ                                            |
| **Hash**        | `0b001000`     | 可変長ハッシュ値                                                |
| **UUID**        | `0b001001`     | 128ビットUUID (16バイト)                                        |
| **DateTime**    | `0b001010`     | 日時 (ミリ秒精度, 8バイト)                                      |
| **Timestamp**   | `0b001011`     | POSIXタイム (秒精度, 8バイト)                                   |
| **Duration**    | `0b001100`     | 期間 (ナノ秒精度, 8バイト)                                      |
| **Array**       | `0b001101`     | 配列                                                            |
| **Object**      | `0b001110`     | キーと値のペア                                                  |
| **WrappedJSON** | `0b001111`     | JSON文字列をラップして格納                                      |
| **Meta**        | `0b010000`     | TON内部用のメタ情報 (ユーザー操作不可)                          |

---

## **3. コレクション型**

### **3.1 Object**

| 種類      | 識別子 (6bit)  |
|:----------|:--------------:|
| **Object**| `0b001110`     |

`Object` 型は、**キーと値のペア**を格納する構造です。

#### **構造**
```
<Object Header>
  <6bit: 0b001110> <2bit: 長さサイズ> <8-64bit: データ長（全体）>
  <Key-Value Pair 1> <Key-Value Pair 2> ... <Key-Value Pair n>
```
- **データ長**: オブジェクト全体（すべてのキーと値ペアを含む）のバイト数。

#### **Key-Value Pair**
```
<Key Header> <Key Data> <Value Header> <Value Data>
```
1. **Key**  
   - `Key Header`:  
     ```
     <6bit: キー識別子> <2bit: 長さサイズ> <8-64bit: データ長>
     ```
     - **キー識別子 (6ビット)**:  
       キー文字列を **SHA-256** でハッシュ化し、その **末尾バイト (`hash[31]`) の下位6ビット** を抽出した値。  
         ```plaintext
         # (pseudo-code)
         hash = SHA256("key_string")      # 32 bytes
         key_id_6bit = hash[31] & 0x3F    # 下位6ビットを取り出す
         ```
     - **長さサイズ (2ビット)**: キー文字列長を表すフィールドサイズ。  
     - **データ長 (8-64ビット)**: キー文字列のバイト数。  
   - `Key Data`: キー文字列本体（UTF-8）。  

2. **Value**  
   - `Value Header`:  
     ```
     <6bit: 値の型識別子> <2bit: 長さサイズ> <8-64bit: データ長>
     ```
     - ここでいう6ビットは**上表にある「基本型識別子」またはコレクション識別子**となる。  
   - `Value Data`: 値データ本体。  

#### **例**
```json
{
  "name": "Alice",
  "age": 25
}
```

TON形式 (概略):
```
<Object Header>
0b001110 0b01 0x13 0x00
  # Object(0b001110), データ長=19 bytes (2バイト指定)

<Key-Value Pair 1>
  <Key Header>
    # "name" → sha256("name") → hash[31] & 0x3F → 例えば 0b100111 (仮)
    0b100111 0b01 0x04 0x00
  <Key Data>
    "name"
  <Value Header>
    # 値が "Alice" (String: 0b000110)
    0b000110 0b01 0x05 0x00
  <Value Data>
    "Alice"

<Key-Value Pair 2>
  <Key Header>
    # "age" → sha256("age") → hash[31] & 0x3F → 例えば 0b011011 (仮)
    0b011011 0b01 0x03 0x00
  <Key Data>
    "age"
  <Value Header>
    # 値が 25 (Int<n>: 0b000010)
    0b000010 0b01 0x01 0x00
  <Value Data>
    0x19  (25)
```

---

### **3.2 Array**

| 種類        | 識別子 (6bit)  |
|:------------|:--------------:|
| **Array**   | `0b001101`     |

`Array` 型は、**複数の値**を格納するデータ構造です。

#### **構造**
```
<Array Header>
  <6bit: 0b001101> <2bit: 長さサイズ> <8-64bit: データ長>
  <Value 1> <Value 2> ... <Value n>
```
- **データ長**: 配列全体のバイト数。

---

### **3.3 WrappedJSON**

| 種類               | 識別子 (6bit)  |
|:-------------------|:--------------:|
| **WrappedJSON**    | `0b001111`     |

`WrappedJSON` は、**JSON文字列をそのまま**格納する特殊型です。

#### **構造**
```
<WrappedJSON Header>
  <6bit: 0b001111> <2bit: 長さサイズ> <8-64bit: データ長>
  <nbyte: JSON文字列>
```

---

### **3.4 Meta**

| 種類   | 識別子 (6bit)  |
|:-------|:--------------:|
| **Meta** | `0b010000`   |

`Meta` は、TON内部の動作を最適化するための**特殊な型**で、ユーザーが直接操作することは**想定されていません**。

#### **構造**
```
<Meta Header>
  <6bit: 0b010000> <2bit: 長さサイズ> <8-64bit: データ長>
  <nbyte: メタ情報>
```

---

## **4. 注意事項**

1. **キー識別子の衝突リスク**  
   - `Object` のキーで使用される6ビットは、**SHA-256の末尾バイトの下位6ビット**から取得するため、  
     別のキー文字列でも**同じ6ビット**になる場合がありえます。  
   - 実際の実装では、**キー文字列本体**（`Key Data`）で最終的な区別を行う必要がある場合があります。  

2. **キーの順序**  
   - `Object` 内のキーはエンコードされた順序が保持されますが、パーサーによって順序が無視される可能性があります。

3. **キーの重複**  
   - 同じ文字列キーを複数回エンコードすることは推奨されません。エラーや後勝ち等、実装依存で扱われる可能性があります。

4. **メタ情報 (`Meta`)**  
   - `Meta` はTON内部専用の型であり、ユーザー操作を**禁止**します。

---

## **5. パーサーポリシー**

1. **キー識別子 (6ビット) の取り扱い**  
   - `Object` 内で読み取る **6ビット** は、あくまで **SHA-256末尾バイトの下位6ビット**という前提。  
   - 実際に衝突していても、最終的には `Key Data` の文字列でキーを認識する実装が望ましい。  

2. **データ長の整合性チェック**  
   - 長さサイズ (2ビット) と実際のバイト数が合わない場合はエラー。  
   - `Value Header` の型識別子に応じたデータ長バリデーションを行う。  

3. **メタ情報の扱い**  
   - `Meta (0b010000)` がユーザー生成データに含まれていたらエラー・警告を返す。内部用途を除き受理しない。  

---

## **6. シリアライザーポリシー**

1. **キー識別子の決定**  
   - `Object` のキー文字列に対して SHA-256 を計算し、**末尾バイト (`hash[31]`) の下位6ビット** をキーの識別子とする。  
   - `<Key Data>` にオリジナルのキー文字列(UTF-8)を入れる。  

2. **最適な長さサイズ**  
   - `データ長` が 255 バイト以内なら `00` … といった形で最小サイズを選ぶ。  
3. **型識別子の正確な設定**  
   - 値としてシリアライズする場合、`Boolean`/`Int<n>`/`String` など **適切な6ビット** を指定する。  
4. **キー重複の防止**  
   - 同一文字列キーが二重に出力されないようにする、または後勝ち等の処理を明示的に行う。  
5. **メタ情報の非ユーザー利用**  
   - ユーザー入力から `Meta` (0b010000) を生成しないようにする。  
   - 内部実装で必要な場合のみ利用。  

## **7. Type Meta について**
Metaの仕様は現在未定義です
